package com.depromeet.mock;

import com.depromeet.pool.domain.FavoritePool;
import com.depromeet.pool.domain.Pool;
import com.depromeet.pool.domain.PoolSearch;
import com.depromeet.pool.domain.vo.PoolSearchPage;
import com.depromeet.pool.port.out.persistence.PoolPersistencePort;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

public class FakePoolRepository implements PoolPersistencePort {
    private Long poolAutoGeneratedId = 0L;
    private Long favoritePoolAutoGeneratedId = 0L;
    private Long poolSerachAutoGeneratedId = 0L;
    private final List<Pool> poolData = new ArrayList<>();
    private final List<FavoritePool> favoritePoolData = new ArrayList<>();
    private final List<PoolSearch> poolSearchData = new ArrayList<>();

    @Override
    public PoolSearchPage findPoolsByNameAndNotIn(
            String nameQuery, Set<Long> favoritePoolIds, Long cursorId) {
        int favoritePoolSize = (favoritePoolIds != null) ? favoritePoolIds.size() : 0;
        int limit = (cursorId == null) ? (10 - favoritePoolSize) : 10;

        // Filter pools by nameQuery and not in favoritePoolIds
        List<Pool> filteredPools =
                poolData.stream()
                        .filter(pool -> pool.getName().contains(nameQuery))
                        .filter(pool -> !favoritePoolIds.contains(pool.getId()))
                        .filter(pool -> cursorId == null || pool.getId() > cursorId)
                        .sorted(Comparator.comparing(Pool::getId))
                        .limit(limit + 1)
                        .collect(Collectors.toList());

        boolean hasNext = filteredPools.size() > limit;
        Long nextCursorId = null;
        if (hasNext) {
            Pool lastPool = filteredPools.removeLast();
            nextCursorId = lastPool.getId();
        }

        return PoolSearchPage.builder()
                .pools(filteredPools)
                .cursorId(nextCursorId)
                .hasNext(hasNext)
                .build();
    }

    @Override
    public List<FavoritePool> findFavoritePools(Long memberId) {
        return favoritePoolData.stream()
                .filter(item -> item.getMember().getId().equals(memberId))
                .toList();
    }

    @Override
    public List<PoolSearch> findSearchedPools(Long memberId) {
        return poolSearchData.stream()
                .filter(item -> item.getMember().getId().equals(memberId))
                .toList();
    }

    @Override
    public Optional<Pool> findById(Long poolId) {
        return poolData.stream().filter(item -> item.getId().equals(poolId)).findAny();
    }

    @Override
    public Optional<FavoritePool> findFavoritePoolById(Long favoritePoolId) {
        return Optional.empty();
    }

    @Override
    public List<FavoritePool> findFavoritePoolsByMemberAndName(Long memberId, String nameQuery) {
        return null;
    }

    @Override
    public Pool save(Pool pool) {
        Pool newPool =
                Pool.builder()
                        .id(++poolAutoGeneratedId)
                        .name(pool.getName())
                        .address(pool.getAddress())
                        .lane(pool.getLane())
                        .build();
        poolData.add(newPool);
        return newPool;
    }

    @Override
    public PoolSearch savePoolSearch(PoolSearch poolSearch) {
        PoolSearch newPoolSearch =
                PoolSearch.builder()
                        .id(++poolSerachAutoGeneratedId)
                        .pool(poolSearch.getPool())
                        .member(poolSearch.getMember())
                        .build();
        poolSearchData.add(newPoolSearch);
        return newPoolSearch;
    }

    @Override
    public FavoritePool saveFavoritePool(FavoritePool favoritePool) {
        FavoritePool newFavoritePool =
                FavoritePool.builder()
                        .id(++favoritePoolAutoGeneratedId)
                        .pool(favoritePool.getPool())
                        .member(favoritePool.getMember())
                        .build();
        favoritePoolData.add(newFavoritePool);
        return newFavoritePool;
    }

    @Override
    public boolean existsFavoritePool(FavoritePool favoritePool) {
        return favoritePoolData.stream()
                .anyMatch(
                        item ->
                                item.getPool().getId().equals(favoritePool.getPool().getId())
                                        && item.getMember()
                                                .getId()
                                                .equals(favoritePool.getMember().getId()));
    }

    @Override
    public void deleteFavoritePool(FavoritePool favoritePool) {
        favoritePoolData.removeIf(
                it ->
                        it.getPool().getId().equals(favoritePool.getPool().getId())
                                && it.getMember().getId().equals(favoritePool.getMember().getId()));
    }
}
